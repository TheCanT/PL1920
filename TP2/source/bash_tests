(./toml2json.exe < ../toml_examples/example-v0.4.toml) > examplev4.json
(./toml2json.exe < ../toml_examples/example-v0.3.toml) > examplev3.json
(./toml2json.exe < ../toml_examples/hard_example_unicode.toml) > hard_unicode.json
(./toml2json.exe < ../toml_examples/fruit.toml) > fruit.json
(./toml2json.exe < ../toml_examples/example.toml) > example.json
(./toml2json.exe < ../toml_examples/input_test.toml) > input.json
(./toml2json.exe < ../toml_examples/xxx.toml) > xxx.json


(./toml2json.exe -xml < ../toml_examples/hard_example_unicode.toml) > hard_unicode.xml
(./toml2json.exe -xml < ../toml_examples/input_test.toml) > input.xml
(./toml2json.exe -xml < ../toml_examples/xxx.toml) > xxx.xml


\chapter{Anexos}

\section{FLEX}
\begin{verbatim}
%option 8bit noyywrap yylineno stack

%{
#include "storedata.h"
#include "y.tab.h"
%}

dig [0-9]
signal [\+\-]



comment_regex #.*



boolean_regex (true|false)



string_key [A-Za-z0-9_\-]+



integer {dig}((_)?{dig})*
hex 0x[0-9A-Fa-f]+
oct 0o[0-7]+
bin 0b[01]+

integer_regex {signal}?{integer}



fractional \.{integer}
exponent [Ee]{signal}?{integer}
inf {signal}?inf
nan {signal}?nan

float_regex ({signal}?{integer}{fractional}?{exponent}?)



offset {dig}{2}:{dig}{2}
local_date {dig}{4}\-{dig}{2}\-{dig}{2}
local_time {dig}{2}:{dig}{2}:{dig}{2}(\.{dig}{1,6})?
local_date_time {local_date}T{local_time}
offset_date_time {local_date_time}(Z|\-{offset})

date_regex ({local_date}|{local_time}|{local_date_time}|{offset_date_time})


%x VALUE IN_LINE_TABLE LIST QUOTE_STR_L APOSTROPHE_STR_L QUOTE_STR APOSTROPHE_STR

%%

<QUOTE_STR>\n {
    yylval.string_value = strdup("\\n");
    return quote_char;
}
<QUOTE_STR>\\ {
    yylval.string_value = strdup("\\");
    return quote_char;
}
<QUOTE_STR>\" {
    yylval.string_value = strdup("\\\"");
    return quote_char;
}
<QUOTE_STR>\\[\n\ ]+ {
    yylval.string_value = "";
    return quote_char;
}

<QUOTE_STR>\"\"\" {
    yy_pop_state();
    if(YYSTATE == VALUE) { yy_pop_state(); }
    return QUOTE_TRI_CLOSE;
}
<VALUE>\"\"\"\n? {
    yy_push_state(QUOTE_STR);
    return QUOTE_TRI_OPEN;
}

<QUOTE_STR_L,QUOTE_STR>\\\" {
    yylval.string_value = strdup(yytext);
    return quote_char;
}
<QUOTE_STR_L>\" {
    yy_pop_state();
    if(YYSTATE == VALUE) { yy_pop_state(); }
    return QUOTE_CLOSE;
}
<INITIAL,VALUE,LIST,IN_LINE_TABLE>\" {
    yy_push_state(QUOTE_STR_L);
    return QUOTE_OPEN;
}

<QUOTE_STR,QUOTE_STR_L>[^\n] {
    yylval.string_value = strdup(yytext);
    return quote_char;
}




<APOSTROPHE_STR,APOSTROPHE_STR_L>\\ {
    yylval.string_value = strdup("\\\\");
    return apostrophe_char;
}
<APOSTROPHE_STR,APOSTROPHE_STR_L>\" {
    yylval.string_value = strdup("\\\"");
    return apostrophe_char;
}

<APOSTROPHE_STR>\n {
    yylval.string_value = strdup("\\n");
    return apostrophe_char;
}
<APOSTROPHE_STR>\\\' {
    yylval.string_value = strdup(yytext);
    return apostrophe_char;
}
<APOSTROPHE_STR>[^\'\n] {
    yylval.string_value = strdup(yytext);
    return apostrophe_char;
}
<APOSTROPHE_STR>\'\'\' {
    yy_pop_state();
    if(YYSTATE == VALUE) { yy_pop_state(); }
    return APOSTROPHE_TRI_CLOSE;
}
<VALUE>\'\'\'\n? {
    yy_push_state(APOSTROPHE_STR);
    return APOSTROPHE_TRI_OPEN;
}

<APOSTROPHE_STR_L>\' {
    yy_pop_state();
    if(YYSTATE == VALUE) { yy_pop_state(); }
    return APOSTROPHE_CLOSE;
}
<INITIAL,VALUE,LIST,IN_LINE_TABLE>\' {
    yy_push_state(APOSTROPHE_STR_L);
    return APOSTROPHE_OPEN;
}

<APOSTROPHE_STR,APOSTROPHE_STR_L>[^\n] {
    yylval.string_value = strdup(yytext);
    return apostrophe_char;
}




<VALUE>\n { yy_pop_state(); }


<*>[ \t\n\r] ;


<*>\. {
    return KEY_TOKEN;
}


<LIST,IN_LINE_TABLE>\, {
    if(YYSTATE == VALUE) { yy_pop_state(); }
    return SEPARATE_VALUES; 
}


<IN_LINE_TABLE>\} {
    yy_pop_state();
    if(YYSTATE == VALUE) { yy_pop_state(); }
    return CLOSE_IN_LINE_TABLE;
}


<VALUE,LIST>\{ {
    yy_push_state(IN_LINE_TABLE);
    return OPEN_IN_LINE_TABLE;
}


<LIST>\] {
    yy_pop_state();
    if(YYSTATE == VALUE) { yy_pop_state(); }
    return CLOSE_LIST;
}


<VALUE,LIST>\[ {
    yy_push_state(LIST);
    return OPEN_LIST;
}


<*>\= {
    yy_push_state(VALUE);
    return KEY_EQ_VALUE;
}


<VALUE,LIST>{boolean_regex} {
    if(YYSTATE == VALUE) yy_pop_state();
    yylval.string_value = strdup(yytext);
    return boolean;
}


<VALUE,LIST>{integer_regex} {
    if(YYSTATE == VALUE) yy_pop_state();
    yylval.string_value = strdup(yytext);
    return integer;
}


<VALUE,LIST>{hex} {
    if(YYSTATE == VALUE) yy_pop_state();
    yylval.string_value = strdup(yytext);
    return hex_numeric;
}


<VALUE,LIST>{oct} {
    if(YYSTATE == VALUE) yy_pop_state();
    yylval.string_value = strdup(yytext);
    return oct_numeric;
}


<VALUE,LIST>{bin} {
    if(YYSTATE == VALUE) yy_pop_state();
    yylval.string_value = strdup(yytext);
    return bin_numeric;
}


<VALUE,LIST>{float_regex} {
    if(YYSTATE == VALUE) yy_pop_state();
    yylval.string_value = strdup(yytext);
    return yyfloat;
}


<VALUE,LIST>({inf}|{nan}) {
    if(YYSTATE == VALUE) yy_pop_state();
    yylval.string_value = strdup(yytext);
    return undifined_numeric;
}


<VALUE,LIST>{date_regex} {
    if(YYSTATE == VALUE) yy_pop_state();
    yylval.string_value = strdup(yytext);
    return date;
}



<INITIAL>\] {
    return CLOSE_TABLE;
}


<INITIAL>\[ {
    return OPEN_TABLE;
}


<INITIAL>\]\] {
    return CLOSE_ARRAY_OF_TABLES;
}


<INITIAL>\[\[ {
    return OPEN_ARRAY_OF_TABLES;
}


<INITIAL,IN_LINE_TABLE>{string_key} {
    yylval.string_value = strdup(yytext);
    return string_key;
}




<INITIAL,LIST,VALUE>{comment_regex} ;


<*><<EOF>> {
   return END;
}


<*>. {
   puts("ERROR TOKEN");
   return 0;
}

%%
\end{verbatim}


\section{GIC}
\begin{verbatim}
S
    : Sequence END
;

Sequence
    : Sequence Sequencable
    | Sequencable
;

Sequencable
    : Pair
    | Table
    | ArrayOfTables
;

Table
    : OPEN_TABLE Key CLOSE_TABLE 
;

ArrayOfTables
    : OPEN_ARRAY_OF_TABLES Key CLOSE_ARRAY_OF_TABLES
;

InLineTable
    : OPEN_IN_LINE_TABLE InLinable CLOSE_IN_LINE_TABLE
;

InLinable
    : Pair
    | InLinable SEPARATE_VALUES Pair
;

List
    : OPEN_LIST Listable CLOSE_LIST
;

Listable
    : Value
    | Listable SEPARATE_VALUES Value
    | Listable SEPARATE_VALUES
;

Pair
    : Key KEY_EQ_VALUE Value
;

Key
    : DottedKey KeyString
;

DottedKey
    : DottedKey KeyString KEY_TOKEN
    | &
;

KeyString
    : string_key
    | APOSTROPHE_OPEN ApostropheString APOSTROPHE_CLOSE
    | QUOTE_OPEN QuoteString QUOTE_CLOSE
;

Value
    : String
    | Numeric 
    | boolean 
    | date  
    | List 
    | InLineTable 
;

String
    : APOSTROPHE_TRI_OPEN ApostropheString APOSTROPHE_TRI_CLOSE
    | QUOTE_TRI_OPEN QuoteString QUOTE_TRI_CLOSE
    | APOSTROPHE_OPEN ApostropheString APOSTROPHE_CLOSE
    | QUOTE_OPEN QuoteString QUOTE_CLOSE 
;

ApostropheString
    : apostrophe_char  
    | ApostropheString apostrophe_char
;

QuoteString
    : quote_char       
    | QuoteString quote_char
;

Numeric
    : yyfloat          
    | integer          
    | hex_numeric      
    | oct_numeric      
    | bin_numeric      
    | undifined_numeric
;
\end{verbatim}


\section{YACC}
\begin{verbatim}
%{
#include <stdio.h>
#include <string.h>

#include "storedata.h"

STOREDATA global_table    = NULL;
STOREDATA table_in_use    = NULL;
STOREDATA in_line_table   = NULL;

GPtrArray * inline_stack  = NULL;

int parsing_InLineTable   = 0;
int parsing_Table         = 0;

extern void asprintf();
extern int yylex();
extern int yylineno;
extern char *yytext;


char * take_of_under_score (char * s);
int yyerror();
int erroSem(char*);
%}

%union{
    char * string_value;
    gpointer pointer;
    STOREDATA store_data;
}


%token OPEN_LIST    // '['
%token CLOSE_LIST   // ']'


%token OPEN_IN_LINE_TABLE   // '{'
%token CLOSE_IN_LINE_TABLE  // '}'


%token OPEN_TABLE   // '['
%token CLOSE_TABLE  // ']'


%token OPEN_ARRAY_OF_TABLES     // '[['
%token CLOSE_ARRAY_OF_TABLES    // ']]'


%token KEY_EQ_VALUE     // '='
%token KEY_TOKEN        // '.'
%token SEPARATE_VALUES  // ','


%token APOSTROPHE_TRI_OPEN  // '''
%token APOSTROPHE_TRI_CLOSE // '''


%token QUOTE_TRI_OPEN   // """
%token QUOTE_TRI_CLOSE  // """


%token APOSTROPHE_OPEN  // '
%token APOSTROPHE_CLOSE // '


%token QUOTE_OPEN   // "
%token QUOTE_CLOSE  // "


%token END // <<EOF>>


%token <string_value>
    undifined_numeric
    apostrophe_char
    hex_numeric
    oct_numeric
    bin_numeric
    string_key
    quote_char
    boolean
    integer
    yyfloat
    date


%type <pointer>
    InLineTable
    InLinable
    Listable
    Value
    List
    Pair

%type <store_data>
    DottedKey
    Key

%type <string_value>
    ApostropheString
    QuoteString
    KeyString 
    Numeric
    String

%%

S :
    { 
        global_table = store_data_new_table("global"); 
        table_in_use = global_table; 
        inline_stack = g_ptr_array_new();
    } 
      Sequence END 
    {
        print_2_JSON(global_table);
        return 0; 
    }
;


Sequence
    : Sequence Sequencable
    | Sequencable
;


Sequencable
    : Pair
    | Table
    | ArrayOfTables
;


Table
    : { 
        table_in_use = global_table;
        parsing_Table = 1;
    }
    OPEN_TABLE Key CLOSE_TABLE 
    {
        table_in_use = $3;
        if (store_data_get_type($3) == 'v') {
            store_data_set_data($3,g_hash_table_new(g_str_hash,g_str_equal));
            store_data_set_type($3,'h');
        }

        parsing_Table = 0;
    }
;


ArrayOfTables
    : { 
        table_in_use = global_table;
        parsing_Table = 1;
    } 
    OPEN_ARRAY_OF_TABLES Key CLOSE_ARRAY_OF_TABLES
    {
        if (store_data_get_type($3) != 'a') {
            store_data_set_data($3,g_ptr_array_new());
            store_data_set_type($3,'a');
        }
        
        STOREDATA s = store_data_new_table("");
        store_data_add_value($3,s);

        table_in_use = s;
        parsing_Table = 0;
    }
;


InLineTable
    : OPEN_IN_LINE_TABLE InLinable CLOSE_IN_LINE_TABLE { 
        $$ = $2;
        parsing_InLineTable--;
        if (parsing_InLineTable > 0) in_line_table = g_ptr_array_index(inline_stack,parsing_InLineTable-1);
    }
;


InLinable
    : {
        in_line_table = store_data_new_table("");
        g_ptr_array_insert(inline_stack, parsing_InLineTable, in_line_table); 
        parsing_InLineTable++;
    } 
    Pair 
    { 
        $$ = g_ptr_array_index(inline_stack,parsing_InLineTable-1); 
    }
    | InLinable SEPARATE_VALUES Pair { $$ = $1; }
;


List
    : OPEN_LIST Listable CLOSE_LIST { $$ = $2; }
;


Listable
    : Value { 
        STOREDATA s = store_data_new_array(""); 
        store_data_add_value(s,$1);
        $$ = s;
    }
    | Listable SEPARATE_VALUES Value { store_data_add_value($1,$3); $$ = $1; }
    | Listable SEPARATE_VALUES       { $$ = $1; }
;


Pair
    : Key KEY_EQ_VALUE Value {
        if (store_data_get_type($1) == 'v') {
            store_data_set_key($3,store_data_get_key($1));
            store_data_add_value($1,$3);
        }

        $$ = $1;
    }
;


Key
    : DottedKey KeyString { $$ = store_data_next_key_value($1,$2); if (!$$) return erroSem("Key NULL");}
;


DottedKey
    : DottedKey KeyString KEY_TOKEN { $$ = store_data_next_key($1,$2); }
    | { 
        if (parsing_InLineTable > 0 && !parsing_Table) $$ = in_line_table;
        else $$ = table_in_use;
    }
;


KeyString
    : string_key                                        { asprintf(&$$,"%s",$1); }
    | APOSTROPHE_OPEN ApostropheString APOSTROPHE_CLOSE { asprintf(&$$,"%s",$2); }
    | QUOTE_OPEN QuoteString QUOTE_CLOSE                { asprintf(&$$,"%s",$2); }
;


Value
    : String        { $$ = store_data_new('s', "", $1); }
    | Numeric       { $$ = store_data_new('s', "", $1); }
    | boolean       { $$ = store_data_new('s', "", $1); }
    | date          { char * s; asprintf(&s,"\"%s\"",$1); $$ = store_data_new('s', "", s); }
    | List          { $$ = $1; }
    | InLineTable   { $$ = $1; }
;


String
    : APOSTROPHE_TRI_OPEN ApostropheString APOSTROPHE_TRI_CLOSE { asprintf(&$$,"\"%s\"",$2); }
    | QUOTE_TRI_OPEN QuoteString QUOTE_TRI_CLOSE                { asprintf(&$$,"\"%s\"",$2); }
    | APOSTROPHE_OPEN ApostropheString APOSTROPHE_CLOSE         { asprintf(&$$,"\"%s\"",$2); }
    | QUOTE_OPEN QuoteString QUOTE_CLOSE                        { asprintf(&$$,"\"%s\"",$2); }
;


ApostropheString
    : apostrophe_char                  { asprintf(&$$,"%s",$1); }
    | ApostropheString apostrophe_char { asprintf(&$$,"%s%s",$1,$2); }
;


QuoteString
    : quote_char             { asprintf(&$$,"%s",$1); }
    | QuoteString quote_char { asprintf(&$$,"%s%s",$1,$2); }
;


Numeric
    : yyfloat           { $$ = take_of_under_score( *$1 == '+' ? $1 + 1 : $1 ); }
    | integer           { $$ = take_of_under_score( *$1 == '+' ? $1 + 1 : $1 ); }
    | hex_numeric       { asprintf(&$$,"%ld",strtol($1+2,NULL,16)); }
    | oct_numeric       { asprintf(&$$,"%ld",strtol($1+2,NULL,8)); }
    | bin_numeric       { asprintf(&$$,"%ld",strtol($1+2,NULL,2)); }
    | undifined_numeric { asprintf(&$$,"\"%s\"",$1); }
;

%%

int main(){
    yyparse();
    return 0;
}

int erroSem(char *s){
    printf("Erro Semântico na linha: %d, %s...\n", yylineno, s);
    return 0;
}

int yyerror(){
    printf("Erro Sintático ou Léxico na linha: %d, com o texto: %s\n", yylineno, yytext);
    return 0;
}

char * take_of_under_score (char * s) {
    char * r = malloc(strlen(s));
    int i = 0, j = 0;
    
    while (s[i]) {
        if (s[i] != '_') r[j++] = s[i]; 
        i++;
    }
    r[j] = '\0';
    
    return r; 
}
\end{verbatim}


\section{Exemplos \textit{TOML}}
\subsection{Exemplo 1}
\begin{verbatim}
# This is a TOML document. Boom.

title = "TOML Example"

[owner]
name = "Tom Preston-Werner"
organization = "GitHub"
bio = "GitHub Cofounder & CEO\nLikes tater tots and beer."
dob = 1979-05-27T07:32:00Z # First class dates? Why not?

[database]
server = "192.168.1.1"
ports = [ 8001, 8001, 8002 ]
connection_max = 5000
enabled = true

[servers]

  # You can indent as you please. Tabs or spaces. TOML don't care.
  [servers.alpha]
  ip = "10.0.0.1"
  dc = "eqdc10"

  [servers.beta]
  ip = "10.0.0.2"
  dc = "eqdc10"
  country = "中国" # This should be parsed as UTF-8

[clients]
data = [ ["gamma", "delta"], [1, 2] ] # just an update to make sure parsers support it

# Line breaks are OK when inside arrays
hosts = [
  "alpha",
  "omega"
]

# Products

  [[products]]
  name = "Hammer"
  sku = 738594937

  [[products]]
  name = "Nail"
  sku = 284758393
  color = "gray"
\end{verbatim}

\subsection{Exemplo 2}
\begin{verbatim}
# Comment
# I am a comment. Hear me roar. Roar.

# Table
# Tables (also known as hash tables or dictionaries) are collections of key/value pairs.
# They appear in square brackets on a line by themselves.

[Table]

key = "value" # Yeah, you can do this.

# Nested tables are denoted by table names with dots in them. Name your tables whatever crap you please, just don't use #, ., [ or ].

[dog.tater]
type = "pug"

# You don't need to specify all the super-tables if you don't want to. TOML knows how to do it for you.

# [x] you
# [x.y] don't
# [x.y.z] need these
[x.y.z.w] # for this to work

# String
# There are four ways to express strings: basic, multi-line basic, literal, and multi-line literal.
# All strings must contain only valid UTF-8 characters.

[String]
basic = "I'm a string. \"You can quote me\". Name\tJos\u00E9\nLocation\tSF."

[String.Multiline]

# The following strings are byte-for-byte equivalent:
key1 = "One\nTwo"
key2 = """One\nTwo"""
key3 = """
One
Two"""

[String.Multilined.Singleline]

# The following strings are byte-for-byte equivalent:
key1 = "The quick brown fox jumps over the lazy dog."

key2 = """
The quick brown \


  fox jumps over \
    the lazy dog."""

key3 = """\
       The quick brown \
       fox jumps over \
       the lazy dog.\
       """

[String.Literal]

# What you see is what you get.
winpath  = 'C:\Users\nodejs\templates'
winpath2 = '\\ServerX\admin$\system32\'
quoted   = 'Tom "Dubs" Preston-Werner'
regex    = '<\i\c*\s*>'


[String.Literal.Multiline]

regex2 = '''I [dw]on't need \d{2} apples'''
lines  = '''
The first newline is
trimmed in raw strings.
   All other whitespace
   is preserved.
'''

# Integer
# Integers are whole numbers. Positive numbers may be prefixed with a plus sign.
# Negative numbers are prefixed with a minus sign.

[Integer]
key1 = +99
key2 = 42
key3 = 0
key4 = -17

# Float
# A float consists of an integer part (which may be prefixed with a plus or minus sign)
# followed by a fractional part and/or an exponent part.

[Float.fractional]

# fractional
key1 = +1.0
key2 = 3.1415
key3 = -0.01

[Float.exponent]

# exponent
key1 = 5e+22
key2 = 1e6
key3 = -2E-2

[Float.both]

# both
key = 6.626e-34

# Boolean
# Booleans are just the tokens you're used to. Always lowercase.

[Booleans]
True = true
False = false

# Datetime
# Datetimes are RFC 3339 dates.

[Datetime]
key1 = 1979-05-27T07:32:00Z
key2 = 1979-05-27T00:32:00-07:00
key3 = 1979-05-27T00:32:00.999999-07:00

# Array
# Arrays are square brackets with other primitives inside. Whitespace is ignored. Elements are separated by commas. Data types may not be mixed.

[Array]
key1 = [ 1, 2, 3 ]
key2 = [ "red", "yellow", "green" ]
key3 = [ [ 1, 2 ], [3, 4, 5] ]
key4 = [ [ 1, 2 ], ["a", "b", "c"] ] # this is ok

#Arrays can also be multiline. So in addition to ignoring whitespace, arrays also ignore newlines between the brackets.
# Terminating commas are ok before the closing bracket.

key5 = [
  1, 2, 3
]
key6 = [
  1,
  2, # this is ok
]

# Array of Tables
# These can be expressed by using a table name in double brackets.
# Each table with the same double bracketed name will be an element in the array.
# The tables are inserted in the order encountered.

[[products]]
name = "Hammer"
sku = 738594937

[[products]]

[[products]]
name = "Nail"
sku = 284758393
color = "gray"


# You can create nested arrays of tables as well.

[[fruit]]
  name = "apple"

  [fruit.physical]
    color = "red"
    shape = "round"

  [[fruit.variety]]
    name = "red delicious"

  [[fruit.variety]]
    name = "granny smith"

[[fruit]]
  name = "banana"

  [[fruit.variety]]
    name = "plantain"
\end{verbatim}

\subsection{Exemplo 3}
\begin{verbatim}
################################################################################
## Comment

# Speak your mind with the hash symbol. They go from the symbol to the end of
# the line.


################################################################################
## Table

# Tables (also known as hash tables or dictionaries) are collections of
# key/value pairs. They appear in square brackets on a line by themselves.

[table]

key = "value" # Yeah, you can do this.

# Nested tables are denoted by table names with dots in them. Name your tables
# whatever crap you please, just don't use #, ., [ or ].

[table.subtable]

key = "another value"

# You don't need to specify all the super-tables if you don't want to. TOML
# knows how to do it for you.

# [x] you
# [x.y] don't
# [x.y.z] need these
[x.y.z.w] # for this to work


################################################################################
## Inline Table

# Inline tables provide a more compact syntax for expressing tables. They are
# especially useful for grouped data that can otherwise quickly become verbose.
# Inline tables are enclosed in curly braces `{` and `}`. No newlines are
# allowed between the curly braces unless they are valid within a value.

[table.inline]

name = { first = "Tom", last = "Preston-Werner" }
point = { x = 1, y = 2 }


################################################################################
## String

# There are four ways to express strings: basic, multi-line basic, literal, and
# multi-line literal. All strings must contain only valid UTF-8 characters.

[string.basic]

basic = "I'm a string. \"You can quote me\". Name\tJos\u00E9\nLocation\tSF."

[string.multiline]

# The following strings are byte-for-byte equivalent:
key1 = "One\nTwo"
key2 = """One\nTwo"""
key3 = """
One
Two"""

[string.multiline.continued]

# The following strings are byte-for-byte equivalent:
key1 = "The quick brown fox jumps over the lazy dog."

key2 = """
The quick brown \


  fox jumps over \
    the lazy dog."""

key3 = """\
       The quick brown \
       fox jumps over \
       the lazy dog.\
       """

[string.literal]

# What you see is what you get.
winpath  = 'C:\Users\nodejs\templates'
winpath2 = '\\ServerX\admin$\system32\'
quoted   = 'Tom "Dubs" Preston-Werner'
regex    = '<\i\c*\s*>'


[string.literal.multiline]

regex2 = '''I [dw]on't need \d{2} apples'''
lines  = '''
The first newline is
trimmed in raw strings.
   All other whitespace
   is preserved.
'''


################################################################################
## Integer

# Integers are whole numbers. Positive numbers may be prefixed with a plus sign.
# Negative numbers are prefixed with a minus sign.

[integer]

key1 = +99
key2 = 42
key3 = 0
key4 = -17

[integer.underscores]

# For large numbers, you may use underscores to enhance readability. Each
# underscore must be surrounded by at least one digit.
key1 = 1_000
key2 = 5_349_221
key3 = 1_2_3_4_5     # valid but inadvisable


################################################################################
## Float

# A float consists of an integer part (which may be prefixed with a plus or
# minus sign) followed by a fractional part and/or an exponent part.

[float.fractional]

key1 = +1.0
key2 = 3.1415
key3 = -0.01

[float.exponent]

key1 = 5e+22
key2 = 1e6
key3 = -2E-2

[float.both]

key = 6.626e-34

[float.underscores]

key1 = 9_224_617.445_991_228_313
key2 = 1e1_000


################################################################################
## Boolean

# Booleans are just the tokens you're used to. Always lowercase.

[boolean]

True = true
False = false


################################################################################
## Datetime

# Datetimes are RFC 3339 dates.

[datetime]

key1 = 1979-05-27T07:32:00Z
key2 = 1979-05-27T00:32:00-07:00
key3 = 1979-05-27T00:32:00.999999-07:00


################################################################################
## Array

# Arrays are square brackets with other primitives inside. Whitespace is
# ignored. Elements are separated by commas. Data types may not be mixed.

[array]

key1 = [ 1, 2, 3 ]
key2 = [ "red", "yellow", "green" ]
key3 = [ [ 1, 2 ], [3, 4, 5] ]
key4 = [ [ 1, 2 ], ["a", "b", "c"] ] # this is ok

# Arrays can also be multiline. So in addition to ignoring whitespace, arrays
# also ignore newlines between the brackets.  Terminating commas are ok before
# the closing bracket.

key5 = [
  1, 2, 3
]
key6 = [
  1,
  2, # this is ok
]


################################################################################
## Array of Tables

# These can be expressed by using a table name in double brackets. Each table
# with the same double bracketed name will be an element in the array. The
# tables are inserted in the order encountered.

[[products]]

name = "Hammer"
sku = 738594937

[[products]]

[[products]]

name = "Nail"
sku = 284758393
color = "gray"


# You can create nested arrays of tables as well.

[[fruit]]
  name = "apple"

  [fruit.physical]
    color = "red"
    shape = "round"

  [[fruit.variety]]
    name = "red delicious"

  [[fruit.variety]]
    name = "granny smith"

[[fruit]]
  name = "banana"

  [[fruit.variety]]
    name = "plantain"
\end{verbatim}

\subsection{Exemplo 4}